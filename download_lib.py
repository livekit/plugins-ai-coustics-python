# This file is automatically generated. Do not edit manually.

# Downloads a prebuilt cdylib for audio-filter-uniffi.
# By default, it will download the latest release for the current platform.

import argparse
import os
import platform
import shutil
import sys
import tempfile
from urllib.request import urlopen
from zipfile import ZipFile

PACKAGE_NAME = "audio_filter_uniffi"
PACKAGE_VERSION = "0.1.0"
DOWNLOAD_BASE_URL = "https://github.com/livekit/example/releases/download/example/build"


def target_os():
    if sys.platform.startswith("win"):
        return "windows"
    elif sys.platform.startswith("darwin"):
        return "macos"
    elif sys.platform.startswith("linux"):
        return "linux"

    return None


def target_arch():
    arch = platform.machine().lower()
    arch_mapping = {
        "amd64": "x86_64",
        "x86_64": "x86_64",
        "arm64": "arm64",
        "aarch64": "arm64",
        "armv7": "armv7",
        "armv7l": "armv7",
    }

    if os.environ.get("CIBUILDWHEEL") and target_os() == "macos":
        archflags = os.environ.get("ARCHFLAGS", "")
        return "arm64" if "arm64" in archflags else "x86_64"

    return arch_mapping.get(arch)


def platform_lib_name(platform):
    if platform == "windows":
        return "%s.dll" % PACKAGE_NAME
    elif platform == "macos":
        return "lib%s.dylib" % PACKAGE_NAME
    else:
        return "lib%s.so" % PACKAGE_NAME


def download_lib(platform, arch, version, output, skip):
    if skip and os.path.exists(output):
        print("Library already exists at %s" % os.path.abspath(output))
        return

    filename = "ffi-%s-%s.zip" % (platform, arch)
    lib_name = platform_lib_name(platform)
    url = "%s@%s/%s" % (DOWNLOAD_BASE_URL, version, filename)
    tmp = os.path.join(tempfile.gettempdir(), filename)

    print(f"Version  : {version}")
    print(f"Platform : {platform}")
    print(f"Arch     : {arch}")
    print(f"Name     : {lib_name}")
    print(f"URL      : {url}\n")
    print("Downloading library...")

    with urlopen(url) as resp:
        with open(tmp, mode="wb") as f:
            shutil.copyfileobj(resp, f)

    with ZipFile(tmp) as zip_file:
        os.makedirs(output, exist_ok=True)
        zip_file.extract(lib_name, output)

    print("Downloaded library to %s" % os.path.abspath(output))


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--platform",
        help="target platform",
        default=target_os(),
        choices=["macos", "linux", "windows", "ios", "android"],
    )
    parser.add_argument(
        "--arch",
        help="target architecture",
        default=target_arch(),
        choices=["x86_64", "arm64", "armv7"],
    )
    parser.add_argument(
        "--version",
        help="version to download",
        default=PACKAGE_VERSION,
    )
    parser.add_argument("--output", help="output path", default="src/%s" % PACKAGE_NAME)
    parser.add_argument(
        "--skip",
        help="skip if library already exists",
        action="store_true",
        default=False,
    )
    args = parser.parse_args()

    try:
        download_lib(
            args.platform,
            args.arch,
            args.version,
            os.path.abspath(args.output),
            args.skip,
        )
    except Exception as e:
        print("Error: %s" % str(e), file=sys.stderr)
        sys.exit(1)
